"""
Project generated by builder 0.6.5.
"""

import atexit
import logging
import os
import struct
from platform import system
from ctypes import (Array, byref, c_char_p, c_int, c_size_t, c_ubyte, c_uint, c_ushort, c_void_p, c_wchar_p, cast,
                    CDLL, CFUNCTYPE, create_string_buffer, Structure)
from sys import version_info
try:
    from typing import overload, Sequence, Union
except ImportError:
    def overload(method):
        return method

    class _GenericTypeMeta(type):
        def __getitem__(self, _):
            return None

    class Union(metaclass=_GenericTypeMeta):
        pass

    class Sequence(metaclass=_GenericTypeMeta):
        pass

logger = logging.getLogger("eplab")
URPC_BUILDER_VERSION_MAJOR = 0
URPC_BUILDER_VERSION_MINOR = 6
URPC_BUILDER_VERSION_BUGFIX = 5
URPC_BUILDER_VERSION = f"{URPC_BUILDER_VERSION_MAJOR}.{URPC_BUILDER_VERSION_MINOR}.{URPC_BUILDER_VERSION_BUGFIX}"

_OK = 0
_ERROR = -1
_NOT_IMPLEMENTED = -2
_VALUE_ERROR = -3
_NO_DEVICE = -4
_DEVICE_UNDEFINED = -1


class _IterableStructure(Structure):
    def __iter__(self):
        return (getattr(self, n) for n, t in self._fields_)


def _get_full_path(name: str) -> str:
    """
    Returns full path to file with given name.
    :param name: name of file.
    :return: full path.
    """

    return os.path.join(os.path.dirname(os.path.abspath(__file__)), name)


def _load_lib() -> CDLL:
    """
    Function loads library.
    :return: library.
    """

    os_kind = system().lower()
    if os_kind == "windows":
        if 8 * struct.calcsize("P") == 32:
            lib = CDLL(_get_full_path("resources/win32/urpcbase.dll"))
        else:
            lib = CDLL(_get_full_path("resources/win64/urpcbase.dll"))
    elif os_kind == "linux":
        lib = CDLL(_get_full_path("resources/debian/liburpcbase.so"))
    else:
        raise RuntimeError("unexpected OS")
    return lib


def _normalize_arg(value, desired_ctype):
    from collections import Sequence
    if isinstance(value, desired_ctype):
        return value
    if issubclass(desired_ctype, Array) and isinstance(value, Sequence):
        member_type = desired_ctype._type_
        if desired_ctype._length_ < len(value):
            raise ValueError()
        if issubclass(member_type, c_ubyte) and isinstance(value, bytes):
            return desired_ctype.from_buffer_copy(value)
        if issubclass(member_type, c_ubyte) and isinstance(value, bytearray):
            return desired_ctype.from_buffer(value)
        return desired_ctype(*value)
    return desired_ctype(value)


def _validate_call(result):
    if result == _VALUE_ERROR:
        raise ValueError()
    if result == _NOT_IMPLEMENTED:
        raise NotImplementedError()
    if result != _OK:
        raise RuntimeError()


# Hack to prevent auto-conversion to native Python int
class _device_t(c_int):
    def from_param(self, *args):
        return self


@CFUNCTYPE(None, c_int, c_wchar_p, c_void_p)
def logging_callback(loglevel, message, user_data):
    if loglevel == 0x01:
        logger.error(message)
    elif loglevel == 0x02:
        logger.warning(message)
    elif loglevel == 0x03:
        logger.info(message)
    elif loglevel == 0x04:
        logger.debug(message)


_lib = _load_lib()
_lib.urpcbase_open_device.restype = _device_t
_lib.urpcbase_set_logging_callback(logging_callback)
atexit.register(lambda: _lib.urpcbase_set_logging_callback(None))


def reset_locks():
    _validate_call(_lib.urpcbase_reset_locks())


def fix_usbser_sys():
    _validate_call(_lib.urpcbase_fix_usbser_sys())


class UrpcbaseDeviceHandle:

    class GetIdentityInformationResponse(_IterableStructure):
        _fields_ = (("_manufacturer", c_ubyte * 16),
                    ("_product_name", c_ubyte * 16),
                    ("_controller_name", c_ubyte * 16),
                    ("_hardware_major", c_ubyte),
                    ("_hardware_minor", c_ubyte),
                    ("_hardware_bugfix", c_ushort),
                    ("_bootloader_major", c_ubyte),
                    ("_bootloader_minor", c_ubyte),
                    ("_bootloader_bugfix", c_ushort),
                    ("_firmware_major", c_ubyte),
                    ("_firmware_minor", c_ubyte),
                    ("_firmware_bugfix", c_ushort),
                    ("_serial_number", c_uint),
                    ("_reserved", c_ubyte * 8))

        @property
        def manufacturer(self) -> c_ubyte*16:
            return self._manufacturer

        @manufacturer.setter
        def manufacturer(self, value: Union[Sequence[int], c_ubyte * 16]):
            self._manufacturer = _normalize_arg(value, c_ubyte * 16)

        @property
        def product_name(self) -> c_ubyte * 16:
            return self._product_name

        @product_name.setter
        def product_name(self, value: Union[Sequence[int], c_ubyte * 16]):
            self._product_name = _normalize_arg(value, c_ubyte * 16)

        @property
        def controller_name(self) -> c_ubyte * 16:
            return self._controller_name

        @controller_name.setter
        def controller_name(self, value: Union[Sequence[int], c_ubyte * 16]):
            self._controller_name = _normalize_arg(value, c_ubyte * 16)

        @property
        def hardware_major(self) -> c_ubyte:
            return self._hardware_major

        @hardware_major.setter
        def hardware_major(self, value: Union[int, c_ubyte]):
            self._hardware_major = _normalize_arg(value, c_ubyte)

        @property
        def hardware_minor(self) -> c_ubyte:
            return self._hardware_minor

        @hardware_minor.setter
        def hardware_minor(self, value: Union[int, c_ubyte]):
            self._hardware_minor = _normalize_arg(value, c_ubyte)

        @property
        def hardware_bugfix(self) -> c_ushort:
            return self._hardware_bugfix

        @hardware_bugfix.setter
        def hardware_bugfix(self, value: Union[int, c_ushort]):
            self._hardware_bugfix = _normalize_arg(value, c_ushort)

        @property
        def bootloader_major(self) -> c_ubyte:
            return self._bootloader_major

        @bootloader_major.setter
        def bootloader_major(self, value: Union[int, c_ubyte]):
            self._bootloader_major = _normalize_arg(value, c_ubyte)

        @property
        def bootloader_minor(self) -> c_ubyte:
            return self._bootloader_minor

        @bootloader_minor.setter
        def bootloader_minor(self, value: Union[int, c_ubyte]):
            self._bootloader_minor = _normalize_arg(value, c_ubyte)

        @property
        def bootloader_bugfix(self) -> c_ushort:
            return self._bootloader_bugfix

        @bootloader_bugfix.setter
        def bootloader_bugfix(self, value: Union[int, c_ushort]):
            self._bootloader_bugfix = _normalize_arg(value, c_ushort)

        @property
        def firmware_major(self) -> c_ubyte:
            return self._firmware_major

        @firmware_major.setter
        def firmware_major(self, value: Union[int, c_ubyte]):
            self._firmware_major = _normalize_arg(value, c_ubyte)

        @property
        def firmware_minor(self) -> c_ubyte:
            return self._firmware_minor

        @firmware_minor.setter
        def firmware_minor(self, value: Union[int, c_ubyte]):
            self._firmware_minor = _normalize_arg(value, c_ubyte)

        @property
        def firmware_bugfix(self) -> c_ushort:
            return self._firmware_bugfix

        @firmware_bugfix.setter
        def firmware_bugfix(self, value: Union[int, c_ushort]):
            self._firmware_bugfix = _normalize_arg(value, c_ushort)

        @property
        def serial_number(self) -> c_uint:
            return self._serial_number

        @serial_number.setter
        def serial_number(self, value: Union[int, c_uint]):
            self._serial_number = _normalize_arg(value, c_uint)

        @property
        def reserved(self) -> c_ubyte * 8:
            return self._reserved

        @reserved.setter
        def reserved(self, value: Union[Sequence[int], c_ubyte * 8]):
            self._reserved = _normalize_arg(value, c_ubyte * 8)

    class CalibrationSettingsRequest(_IterableStructure):
        _fields_ = (("_reserved0", c_ubyte*4),)

        @property
        def reserved0(self) -> c_ubyte*4:
            return self._reserved0

        @reserved0.setter
        def reserved0(self, value: Union[Sequence[int], c_ubyte * 4]):
            self._reserved0 = _normalize_arg(value, c_ubyte * 4)

    def __init__(self, uri: Union[bytes, bytearray, str], defer_open: bool = False):
        if isinstance(uri, str):
            uri = uri.encode("utf-8")
        if not isinstance(uri, (bytes, bytearray)):
            raise ValueError()
        self._uri = uri
        self._handle = None
        if not defer_open:
            self.open_device()
    if version_info >= (3, 4):
        def __del__(self):
            if self._handle:
                self.close()

    def get_identity_information(self, **kwargs) -> GetIdentityInformationResponse:
        dst_buffer = kwargs.get("dst_buffer", self.GetIdentityInformationResponse())
        _validate_call(_lib.urpcbase_get_identity_information(self._handle, byref(dst_buffer)))
        return dst_buffer

    def reset(self):
        _validate_call(_lib.urpcbase_reset(self._handle))

    def update_firmware(self):
        _validate_call(_lib.urpcbase_update_firmware(self._handle))

    def reboot_to_bootloader(self):
        _validate_call(_lib.urpcbase_reboot_to_bootloader(self._handle))

    def save_robust_settings(self):
        _validate_call(_lib.urpcbase_save_robust_settings(self._handle))

    def read_robust_settings(self):
        _validate_call(_lib.urpcbase_read_robust_settings(self._handle))

    CalibrationSettingsResponse = CalibrationSettingsRequest

    def get_calibration_settings(self, **kwargs) -> "CalibrationSettingsResponse":
        dst_buffer = kwargs.get("dst_buffer", self.CalibrationSettingsResponse())
        _validate_call(_lib.urpcbase_get_calibration_settings(self._handle, byref(dst_buffer)))
        return dst_buffer

    def set_calibration_settings(self, *args):
        if len(args) != 1 or not isinstance(args[0], self.CalibrationSettingsRequest):
            src_buffer = self.CalibrationSettingsRequest(reserved0=_normalize_arg(args[0], c_ubyte*4))
        else:
            src_buffer = args[0]
        _validate_call(_lib.urpcbase_set_calibration_settings(self._handle, byref(src_buffer)))

    @property
    def uri(self) -> bytes:
        return self._uri

    def open_device(self) -> bool:
        if self._handle is not None:
            return False

        handle = _lib.urpcbase_open_device(self._uri)
        if handle.value == _DEVICE_UNDEFINED:
            raise RuntimeError()

        self._handle = handle
        return True

    @staticmethod
    def lib_version() -> str:
        ver_lib = create_string_buffer(str.encode("00.00.00"))
        result = _lib.urpcbase_libversion(ver_lib)
        if result != _OK:
            raise RuntimeError()
        version_lib = ver_lib.value.decode("utf-8")
        return version_lib

    def close(self) -> bool:
        if self._handle is None:
            return False
        try:
            result = _lib.urpcbase_close_device(byref(self._handle))
            if result != _OK:
                raise RuntimeError()
        except Exception:
            raise
        else:
            return True
        finally:
            self._handle = None

    def get_profile(self) -> str:
        buffer = c_char_p()

        @CFUNCTYPE(c_void_p, c_size_t)
        def allocate(size):
            # http://bugs.python.org/issue1574593
            return cast(create_string_buffer(size+1), c_void_p).value

        _validate_call(_lib.urpcbase_get_profile(self._handle, byref(buffer), allocate))
        return buffer.value.decode("utf-8")

    def set_profile(self, source):
        if isinstance(source, str):
            source = source.encode("utf-8")
        _validate_call(_lib.urpcbase_set_profile(self._handle, c_char_p(source), len(source)))
